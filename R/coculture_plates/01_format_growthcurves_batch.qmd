---
title: "Formatting co-culture growth curves from Logphase 600 Plate reader"
author: "Shane Hogle"
date: today
link-citations: true
abstract: "The ancestral (streptomycin sensitive) and evolved (streptomycin resistant) forms of HAMBI_1287 and HAMBI_1977 were grown on adjacent 0.22 um membrane-separated wells in a Verasys co-culture plate. Note that due to the unique format of the plate rows A and H do not contain any data. Measurements were collected with a Biotek Logphase 600 microplate reader."
---

# Setup

## Libraries

```{r}
#| output: false
#| warning: false
#| error: false
library(here)
library(tidyverse)
library(readxl)
library(stringr)
library(lubridate)
library(fs)
library(ggforce)
library(slider)
source(here::here("R", "utils_gcurves.R"))
```

## Global variables

```{r}
#| output: false
#| warning: false
#| error: false
data_raw <- here::here("_data_raw", "coculture_plate")
data <- here::here("data", "coculture_plate")

# make processed data directory if it doesn't exist
fs::dir_create(data)
```

# Tidying growth curves from Synergy H1 multimode microplate reader 

## Read growth curves

```{r}
# plate reading function
read_logphase_xlsx <- function(subdir, filename, sheet, skip){
  readxl::read_xlsx(here::here(data_raw, subdir, filename), sheet = sheet, skip = skip) %>% 
  # set interval start to be first cell and make all intervals relative to that
  # use time_length to just create an hours variable of type numeric
  mutate(seconds = lubridate::time_length(lubridate::interval(Time[1], Time), unit = "second")) %>% 
  tidyr::pivot_longer(c(-seconds, -Time), names_to = "well", values_to = "OD600") %>%
  mutate(hours = lubridate::time_length(seconds, unit = "hours")) %>% 
  # converting the well format so it matches the samplesheet
  mutate(well = paste0(str_extract(well, "^[A-H]"), str_pad(str_extract(well, "\\d+"), 
                                                            width = 2, pad = "0", side = "left"))) %>% 
  dplyr::select(seconds, hours, well, OD600) %>% 
  mutate(OD600 = as.numeric(OD600))
}
```

## Read sample metadata

```{r}
samplesheet_diff_test <- readxl::read_xlsx(here::here(data_raw, "20250920_v2", "diffusion_test_2_samplesheet.xlsx"))
samplesheet_coculture <- readxl::read_xlsx(here::here(data_raw, "20250920_v2", "coculture_samplesheet.xlsx"))
```

```{r}
# Diffusion test plate
diff_test <- read_logphase_xlsx("20250920_v2", "diffusion_test_2_Co-culture_1977_1287AE_12.9_15-syys-2025 09-00-26.xlsx", 2, 1) %>% 
  # remove rows A and H
  filter(str_detect(well, "^A|^H", negate = TRUE)) %>% 
  left_join(samplesheet_diff_test, by = join_by(well)) %>% 
  mutate(plate_name = "diffusion_test")

# Experiment plate 0 ug/ml streptomycin
strep_00 <- read_logphase_xlsx("20250920_v2", "Co-culture_0_4_8ug_plates_22-syys-2025 08-17-10.xlsx", 2, 1) %>% 
  # rows A and H not collected here so they are NA
  drop_na() %>% 
  left_join(samplesheet_coculture, by = join_by(well)) %>% 
  mutate(strep_conc = 0) %>% 
  mutate(plate_name = "str_00")

# Experiment plate 4 ug/ml streptomycin
strep_04 <- read_logphase_xlsx("20250920_v2", "Co-culture_0_4_8ug_plates_22-syys-2025 08-17-10.xlsx", 5, 1) %>% 
  # rows A and H not collected here so they are NA
  drop_na() %>% 
  left_join(samplesheet_coculture, by = join_by(well)) %>% 
  mutate(strep_conc = 4) %>% 
  mutate(plate_name = "str_04")

# Experiment plate 8 ug/ml streptomycin
strep_08 <- read_logphase_xlsx("20250920_v2", "Co-culture_0_4_8ug_plates_22-syys-2025 08-17-10.xlsx", 8, 1) %>% 
  # rows A and H not collected here so they are NA
  drop_na() %>% 
  left_join(samplesheet_coculture, by = join_by(well)) %>% 
  mutate(strep_conc = 8) %>% 
  mutate(plate_name = "str_08")
```

```{r}
# combine all samples, group by plate + well, calculate rolling mean
coculture_gcurves_sm <- bind_rows(diff_test, strep_00, strep_04, strep_08) %>% 
  dplyr::group_by(plate_name, well) %>% 
  arrange(plate_name, well) %>% 
  dplyr::mutate(OD600_rollmean = slider::slide_dbl(OD600, mean, .before = 2, .after = 2)) %>% 
  ungroup() %>% 
  relocate(OD600_rollmean, .after = "OD600")

readr::write_tsv(coculture_gcurves_sm, here::here(data, "coculture_gcurves_smooth.tsv"))
```

# Inspect growth curves

## plate01 (diffusion test)

This plate contains three replicates for the ancestral form of HAMBI_1287

::: {#fig-01}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(coculture_gcurves_sm, dfxy=NULL, unsmoothed=TRUE, predicted=FALSE, plate="diffusion_test", rows=6, cols=12, page=1, scales = "fixed")
```
Growth curves for the "diffusion test" coculture plate. Columns 1, 3, 5, and 7 have only M9 salts. Columns 2, 4, 6, 8, 9, 10, 11, and 12 had R2A medium. Column $n=\{1\dots11\}$ is connected to column $n+1$ with a 0.22 um membrane allowing free diffusion of resources and metabolic byproducts but not cells. Bacteria were inoculated into rows B-D, columns 1, 3, 5, and 7 and rows E-F columsn 2, 4, 6, and 8. Columns 9 and 11 were not inoculated with any bacteria. X-axis is time in hours (48 hour incubation). Y axis is the absorbance scaled for each well. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed. Note that rows A and H are meaningless because of the construction of the plate. Note: rows A and H are blank.
:::

::: {#fig-02}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(coculture_gcurves_sm, dfxy=NULL, unsmoothed=TRUE, predicted=FALSE, plate="str_00", rows=6, cols=12, page=1, scales = "fixed")
```
Growth curves for the coculture plate with no streptomycin. Column $n=\{1\dots11\}$ is connected to column $n+1$ with a 0.22 um membrane allowing free diffusion of resources and metabolic byproducts but not cells. X-axis is time in hours (48 hour incubation). Y axis is the absorbance scaled for each well. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed. Note that rows A and H are meaningless because of the construction of the plate. Note: rows A and H are blank.
:::

::: {#fig-03}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(coculture_gcurves_sm, dfxy=NULL, unsmoothed=TRUE, predicted=FALSE, plate="str_04", rows=6, cols=12, page=1, scales = "fixed")
```
Growth curves for the coculture plate with 4 ug/ml streptomycin. Column $n=\{1\dots11\}$ is connected to column $n+1$ with a 0.22 um membrane allowing free diffusion of resources and metabolic byproducts but not cells. X-axis is time in hours (48 hour incubation). Y axis is the absorbance scaled for each well. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed. Note that rows A and H are meaningless because of the construction of the plate. Note: rows A and H are blank.
:::

::: {#fig-04}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(coculture_gcurves_sm, dfxy=NULL, unsmoothed=TRUE, predicted=FALSE, plate="str_08", rows=6, cols=12, page=1, scales = "fixed")
```
Growth curves for the coculture plate with 8 ug/ml streptomycin. Column $n=\{1\dots11\}$ is connected to column $n+1$ with a 0.22 um membrane allowing free diffusion of resources and metabolic byproducts but not cells. X-axis is time in hours (48 hour incubation). Y axis is the absorbance scaled for each well. Blue line is smoothed with a moving average window of 9 points. Orange is non-smoothed. Note that rows A and H are meaningless because of the construction of the plate. Note: rows A and H are blank.
:::

# Growth curve statistics

```{r}
library("growthrates")
library("DescTools")
```

Using the tool [`growthrates`](https://cran.r-project.org/web/packages/growthrates/index.html) to estimate mu_max. I have found this works a lot better the gcplyr and is more convenient than using another tool outside of R. Nonparametric estimate growth rates by spline is very fast. Fitting to a model takes more time resources. [Generally it is best to try multiple approaches and to visualize/check the data to make sure it makes sense.](https://www.frontiersin.org/journals/ecology-and-evolution/articles/10.3389/fevo.2023.1313500/full)

```{r}
coculture_gcurves_sm <- coculture_gcurves_sm %>% 
  # make uniq id
  mutate(id = paste0(plate_name, "|", well))
```

## Spline based estiamte

Smoothing splines are a quick method to estimate maximum growth. The method is called nonparametric, because the growth rate is directly estimated from the smoothed data without being restricted to a specific model formula.

From [growthrates documentation:](https://cran.r-project.org/web/packages/growthrates/growthrates.pdf)

> The method was inspired by an algorithm of [Kahm et al. (2010)](https://www.jstatsoft.org/article/view/v033i07), with different settings and assumptions. In the moment, spline fitting is always done with log-transformed data, assuming exponential growth at the time point of the maximum of the first derivative of the spline fit. All the hard work is done by function smooth.spline from package stats, that is highly user configurable. Normally, smoothness is automatically determined via cross-validation. This works well in many cases, whereas manual adjustment is required otherwise, e.g. by setting spar to a fixed value \[0, 1\] that also disables cross-validation.

### Fit

```{r}
set.seed(45278)
many_spline <- growthrates::all_splines(OD600_rollmean ~ hours | id, data = coculture_gcurves_sm, spar = 0.5)

readr::write_rds(many_spline, here::here(data, "coculture_spline_fits"))
```

### Results

```{r}
many_spline_res <- growthrates::results(many_spline)
```

### Predictions

```{r}
many_spline_xy <- purrr::map(many_spline@fits, \(x) data.frame(x = x@xy[1], y = x@xy[2])) %>% 
  purrr::list_rbind(names_to = "id") 

many_spline_fitted <- purrr::map(many_spline@fits, \(x) data.frame(x@FUN(x@obs$time, x@par))) %>% 
  purrr::list_rbind(names_to = "id") %>% 
  dplyr::rename(hours = time, predicted = y) %>% 
  dplyr::left_join(coculture_gcurves_sm, by = dplyr::join_by(id, hours)) %>% 
  dplyr::group_by(id) %>% 
  # this step makes sure we don't plot fits that go outside the range of the data
  dplyr::mutate(predicted = dplyr::if_else(dplyr::between(predicted, min(OD600_rollmean), max(OD600_rollmean)), predicted, NA_real_)) %>% 
  dplyr::ungroup()
```

### Plot

#### Plate01

::: {#fig-05}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(many_spline_fitted, dfxy=many_spline_xy, unsmoothed=FALSE, predicted=TRUE, plate="diffusion_test", rows=6, cols=12, page = 1, scales = "fixed")
```
As in @fig-01. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.
:::

::: {#fig-06}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(many_spline_fitted, dfxy=many_spline_xy, unsmoothed=FALSE, predicted=TRUE, plate="str_00", rows=6, cols=12, page = 1, scales = "fixed")
```
As in @fig-02. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.
:::

::: {#fig-07}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(many_spline_fitted, dfxy=many_spline_xy, unsmoothed=FALSE, predicted=TRUE, plate="str_04", rows=6, cols=12, page = 1, scales = "fixed")
```
As in @fig-03. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.
:::

::: {#fig-08}
```{r}
#| fig.width: 12
#| fig.height: 8
#| echo: false
#| warning: false
plotplate(many_spline_fitted, dfxy=many_spline_xy, unsmoothed=FALSE, predicted=TRUE, plate="str_08", rows=6, cols=12, page = 1, scales = "fixed")
```
As in @fig-04. Blue line is smoothed with a moving average window of 5 points. Orange is slope of max predicted growth rate from the first derivative of a smoothing spline. Red dot is hours and OD600 at which maximum growth rate is reached.
:::

## AUC

Calculates AUC using `DescTools` package

```{r}
many_auc_res <- coculture_gcurves_sm %>% 
  dplyr::summarize(auc = DescTools::AUC(hours, OD600_rollmean),
            max_od = max(OD600_rollmean),
            min_od = min(OD600_rollmean),
            .by = id) %>% 
  dplyr::left_join(dplyr::distinct(dplyr::select(coculture_gcurves_sm, strain:id)), by = join_by(id)) %>% 
  dplyr::select(-id)
```

# Write all output

```{r}
readr::write_tsv(many_auc_res, here::here(data, "coculture_gcurve_auc_results.tsv")) 
```

```{r}
many_spline_res %>% 
  dplyr::left_join(dplyr::distinct(dplyr::select(coculture_gcurves_sm, strain:id)), by = join_by(id)) %>% 
  dplyr::select(-id) %>%
  readr::write_tsv(here::here(data, "coculture_gcurve_spline_results.tsv"))
```
